# waiting-system
접속자 폭주로 인한 서버 장애 방지 대기열 시스템

![image](https://github.com/user-attachments/assets/132a014c-3a5f-4b5a-99bb-a23ed1c309f0)


![image](https://github.com/user-attachments/assets/b7ea53b4-345e-4cd6-ad1e-bfa45eb07a5d)

![image](https://github.com/user-attachments/assets/d4cc6cbc-8c3b-4f4d-9eb9-070d7fdf4c00)

![image](https://github.com/user-attachments/assets/7bf82b9b-274a-46d7-9004-17fa5f6ca9f3)


## 문제 정의 요구사항 도출
대기열 시스템은 다음과 같은 요구사항과 특성을 가졌습니다:
- **빠른 대기열 진입 및 순위 응답:** 사용자는 대기열에 빠르게 등록되고 자신의 대기 순위를 즉시 확인할 수 있어야 합니다.
- **자동 순위 갱신:** 대기열 상태는 실시간으로 갱신되며, 새로고침 시 기존 대기열 상태가 유지되어야 합니다.
- **입장 허용 제어:** 특정 인원을 허용하거나 차단할 수 있어야 하며, 입장 허용된 사용자는 다시 대기열을 거치지 않아야 합니다.

## 기술적 접근 및 설계

### 1. 대기열 저장소

Redis의 ZSet을 활용하여 대기열을 구현했습니다. ZSet은 빠른 속도와 함께 score를 기반으로 순위를 결정할 수 있어 대기열 요구사항에 적합했습니다.
### 2. 메시지 브로커 활용 논의

Kafka를 사용해 Redis 이전 단계에서 트래픽을 관리하는 방안을 논의했으나, Kafka의 순서 보장 문제와 자원 낭비를 고려해 적합하지 않다는 결론을 내렸습니다.

### 3. 대기 순위 갱신

- 폴링 방식: 사용자 클라이언트가 주기적으로 순위를 조회하는 간단한 방법. 서버 부하가 커질 가능성이 있지만 구현이 용이합니다.
- SSE 방식: 서버에서 순위 갱신 이벤트를 실시간으로 전송. 실시간성은 뛰어나지만, 대규모 트래픽 상황에서 부하 증가와 Kafka lag 문제를 확인했습니다. 컨슈머를 넉넉히 늘릴 수 있는게 아니라면 폴링 방식이 좋은 선택으로 보였습니다.
부하 테스트(K6)를 통해 폴링 방식이 가용 자원 내에서는 서버 부하를 줄이고 효율적이라는 결과를 얻었습니다.

### 4. 입장 처리
입장 처리는 SSE를 적용했습니다. 순위 갱신에 비해 발행되는 메시지의 수가 현저히 적고 폴링 방식은 입장을 하지 않아도 주기적으로 입장 가능 여부를 체크해야 하기 때문에 비효율적이었습니다.

### 5. 대기열 서비스화
대기열 시스템을 독립적인 서비스로 설계했습니다.
- 각 대기열은 독립적으로 관리되며, 서비스를 사용하는 클라이언트는 대기열 시스템에 등록됩니다.
- 대기열 페이지는 대기열 시스템에서 제공하며, 사용자는 시스템이 발급한 토큰을 통해 인증받아 페이지에 진입합니다.
- 입장 허용 처리:
  - 클라이언트가 입장 허용 API를 호출하면, SSE로 사용자에게 입장 메시지가 전송됩니다.
  - 사용자는 클라이언트가 등록한 redirect URL로 이동하며, 서버는 서명된 토큰을 발급합니다.
  - 클라이언트는 이 토큰을 검증해 쿠키를 발급하여 허용된 사용자 여부를 관리합니다.

### 6. 빠른 처리
WebFlux, Kafka, Redis (Reactive), R2DBC를 활용해 end to end 전체 non-blocking 방식으로 애플리케이션을 운용했습니다.

## 결과
이 시스템은 다양한 대기열 요구사항을 충족하면서도, 유연하고 확장 가능한 구조를 갖추게 되었습니다. 대기열이 필요한 다양한 서비스에서 재사용 가능하며, 트래픽 증가에도 안정적으로 동작할 수 있음을 확인했습니다.
